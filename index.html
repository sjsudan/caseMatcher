<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case Matcher Pro (Export Options)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- SheetJS (Excel) -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3b82f6;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 font-sans">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // ---------------------------------------------------------
        // PDF EXTRACTION LOGIC (High Accuracy)
        // ---------------------------------------------------------
        async function extractTextFromPdf(pdfDocument, updateLog) {
            const fullLines = [];
            const Y_TOLERANCE = 6; 
            
            for (let i = 1; i <= pdfDocument.numPages; i++) {
                if (i % 5 === 0) updateLog(`Scanning page ${i} of ${pdfDocument.numPages}...`);
                const page = await pdfDocument.getPage(i);
                const textContent = await page.getTextContent();
                const items = textContent.items;

                if (items.length === 0) continue;

                const visibleItems = items.filter(item => item.str.trim().length > 0);
                visibleItems.sort((a, b) => {
                    const yDiff = b.transform[5] - a.transform[5];
                    if (Math.abs(yDiff) > Y_TOLERANCE) return yDiff;
                    return a.transform[4] - b.transform[4];
                });

                let currentLine = [];
                let lastY = visibleItems.length > 0 ? visibleItems[0].transform[5] : 0;

                for (const item of visibleItems) {
                    const y = item.transform[5];
                    if (Math.abs(y - lastY) <= Y_TOLERANCE) {
                        currentLine.push(item);
                    } else {
                        if (currentLine.length > 0) processLineItems(currentLine, fullLines);
                        currentLine = [item];
                        lastY = y;
                    }
                }
                if (currentLine.length > 0) processLineItems(currentLine, fullLines);
            }
            return fullLines;
        }

        function processLineItems(lineItems, outputArray) {
            lineItems.sort((a, b) => a.transform[4] - b.transform[4]);
            let lineStr = "";
            let lastX = 0;
            let lastWidth = 0;

            lineItems.forEach((item, idx) => {
                if (idx > 0) {
                    const gap = item.transform[4] - (lastX + lastWidth);
                    if (gap > 4 || item.str.startsWith(" ")) lineStr += " "; 
                }
                lineStr += item.str.trim();
                lastX = item.transform[4];
                lastWidth = item.width;
            });
            if (lineStr.trim()) outputArray.push(lineStr);
        }

        // ---------------------------------------------------------
        // ALGORITHM LOGIC
        // ---------------------------------------------------------

        const normCaseType = (s) => {
            if (!s) return "";
            s = String(s).toUpperCase().trim();
            s = s.replace(/[.\s()]/g, "");
            if (s === "WPCPIL") return "PIL";
            return s;
        };

        const normYear = (token) => {
            if (!token) return "";
            token = String(token).toUpperCase().trim();
            const m = token.match(/^(\d+)\s*\/\s*(\d{2,4})$/);
            if (!m) return token;
            let [_, num, year] = m;
            try { num = String(parseInt(num)).padStart(2, '0'); } catch(e) {}
            if (year.length === 4 && year !== "2000") year = year.slice(-2);
            return `${num}/${year}`;
        };

        const cleanTitleForMatch = (t) => {
            if (!t) return "";
            t = String(t).toUpperCase();
            t = t.replace(/\b(FOR\s+(PET|RES|APPLICANT|RESPONDENT)|CAVEAT|AAG\b|DAG\b|DSGI\b|GA\b|SR\.?\s*ADV|ADV\.)[\w\s\.]*/g, " ");
            t = t.replace(/\bAND\s+OTHERS?\b/g, " ");
            t = t.replace(/\bAND\s+ANR\.?\b/g, " ");
            t = t.replace(/[^\w\s]/g, " ");
            t = t.replace(/\s+/g, " ");
            return t.trim();
        };

        const truncateTitleForDisplay = (title) => {
            if (!title) return "";
            const pat = /\b(FOR\s+(PET|RES|APPLICANT|RESPONDENT)|CAVEAT|AAG\b|DAG\b|DSGI\b|GA\b|SR\.?\s*ADV|ADV\.)\b/i;
            const match = title.match(pat);
            if (match && match.index !== undefined) return title.substring(0, match.index).trim();
            return title;
        };

        const parseBlocks = (lines) => {
            const startPat = /^\s*(\d+)\s+([A-Za-z()\.]+)\s+([A-Za-z0-9\-()/ ]+\/\d{2,4})\s*(.*)$/i;
            const cwInlinePat = /(?:\bc\/w\b|\bwith\b)\s*(?:(?<ctype>[A-Za-z()\.]+)\s+)?(?<cno>[A-Za-z0-9\-() ]+\/\d{2,4})(?:\s+(?<title>[^\n]+))?/gi;

            const rows = [];
            let i = 0;

            while (i < lines.length) {
                const match = lines[i].match(startPat);
                if (!match) { i++; continue; }

                const [_, sno, ctypeRaw, cnoRaw, rest] = match;
                const ctype = normCaseType(ctypeRaw);
                const cno = normYear(cnoRaw);
                let headerTail = (rest || "").trim();

                const titleParts = [];
                if (headerTail) titleParts.push(headerTail);

                let capturingTitle = true;
                let j = i + 1;
                const blockLines = [lines[i]];

                while (j < lines.length) {
                    if (startPat.test(lines[j])) break;
                    const ln = lines[j];
                    blockLines.push(ln);
                    const isClubbed = /^\s*(c\/w|with)\b/i.test(ln);
                    if (isClubbed) capturingTitle = false;
                    if (capturingTitle) titleParts.push(ln.trim());
                    j++;
                }
                i = j;

                rows.push({
                    "S.No": sno,
                    "Case Type": ctype,
                    "Case No.": cno,
                    "Title": titleParts.join(" ").replace(/\s+/g, " ").trim(),
                    "_TitleSrc": "Parsed"
                });

                const blockText = blockLines.join("\n");
                cwInlinePat.lastIndex = 0;
                let m;
                while ((m = cwInlinePat.exec(blockText)) !== null) {
                    const groups = m.groups || {};
                    rows.push({
                        "S.No": sno,
                        "Case Type": normCaseType(groups.ctype || ctype),
                        "Case No.": normYear(groups.cno),
                        "Title": (groups.title || "").trim(),
                        "_TitleSrc": "Clubbed inline"
                    });
                }
            }
            return rows;
        };

        const matchEngine = (row, byCtCno, byCno) => {
            const ct = row["Case Type"];
            const cno = row["Case No."];
            const title = row["Title"] || "";
            const key = `${ct}|${cno}`;
            const recs = byCtCno[key];

            if (recs && recs.length > 0) {
                const fileNos = [...new Set(recs.map(r => String(r["File No."])))].sort();
                const fnoStr = fileNos.join(" | ");
                const first = recs[0];
                const verb = `${fnoStr} ${first["Case Type"]} ${first["Case No."]} ${first["Title"] || ""}`;
                return { fno: fnoStr, verb, chk: `Exact [${fileNos.length}]` };
            }

            const cands = byCno[cno] || [];
            if (cands.length > 0 && title) {
                const tqClean = cleanTitleForMatch(title);
                const tqList = tqClean.split(/\s+/);
                const firstToken = tqList[0];
                let best = null, bestScore = -1;

                for (const cand of cands) {
                    const candTokens = String(cand.title_clean || "").split(/\s+/);
                    if (candTokens.length > 0 && firstToken && candTokens[0] === firstToken) {
                        const fno = cand["File No."];
                        const verb = `${fno} ${cand["Case Type"]} ${cand["Case No."]} ${cand["Title"] || ""}`;
                        return { fno, verb, chk: "Fuzzy (First Token)" };
                    }
                    const candSet = new Set(candTokens);
                    const overlap = tqList.reduce((acc, val) => acc + (candSet.has(val) ? 1 : 0), 0);
                    if (overlap > bestScore) { bestScore = overlap; best = cand; }
                }
                if (best && bestScore >= 1) {
                    const fno = best["File No."];
                    const verb = `${fno} ${best["Case Type"]} ${best["Case No."]} ${best["Title"] || ""}`;
                    return { fno, verb, chk: "Fuzzy (Overlap)" };
                }
            }
            return { fno: "", verb: "", chk: "Not found" };
        };

        // ---------------------------------------------------------
        // UI COMPONENT
        // ---------------------------------------------------------
        function App() {
            const [step, setStep] = useState(1);
            const [masterData, setMasterData] = useState(null);
            const [processedData, setProcessedData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [logs, setLogs] = useState([]);
            const [stats, setStats] = useState(null);
            const [exportMode, setExportMode] = useState('cleaned'); // 'cleaned' or 'full'

            const addLog = (msg) => setLogs(prev => [...prev.slice(-6), msg]); 

            const handleMasterUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setLoading(true);
                addLog(`Reading Master: ${file.name}...`);

                try {
                    const data = await file.arrayBuffer();
                    const workbook = XLSX.read(data);
                    let allRows = [];
                    workbook.SheetNames.forEach(sheetName => {
                        const sheet = workbook.Sheets[sheetName];
                        const json = XLSX.utils.sheet_to_json(sheet);
                        json.forEach(r => r["__sheet__"] = sheetName);
                        allRows = [...allRows, ...json];
                    });

                    addLog(`Indexing ${allRows.length} records...`);
                    const byCtCno = {};
                    const byCno = {};

                    allRows.forEach(r => {
                        const ctNorm = normCaseType(r["Case Type"]);
                        const cnoNorm = normYear(r["Case No."]);
                        r.title_clean = cleanTitleForMatch(r["Title"]);
                        r["Case Type"] = ctNorm; 
                        const key = `${ctNorm}|${cnoNorm}`;
                        if (!byCtCno[key]) byCtCno[key] = [];
                        byCtCno[key].push(r);
                        if (cnoNorm) {
                            if (!byCno[cnoNorm]) byCno[cnoNorm] = [];
                            byCno[cnoNorm].push(r);
                        }
                    });

                    setMasterData({ byCtCno, byCno, count: allRows.length });
                    setLoading(false);
                    setStep(2);
                    addLog("Master DB Ready.");
                } catch (err) {
                    console.error(err);
                    addLog(`Error: ${err.message}`);
                    setLoading(false);
                }
            };

            const handlePdfUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setLoading(true);
                setLogs([]); 
                addLog(`Processing PDF: ${file.name}`);

                try {
                    const buffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(buffer).promise;
                    
                    const fullTextLines = await extractTextFromPdf(pdf, addLog);
                    
                    addLog(`Extracted ${fullTextLines.length} lines. Parsing...`);
                    const parsedRows = parseBlocks(fullTextLines);
                    addLog(`Found ${parsedRows.length} valid cases.`);

                    addLog("Matching against DB...");
                    const results = parsedRows.map(row => {
                        const matchResult = matchEngine(row, masterData.byCtCno, masterData.byCno);
                        return {
                            "S.No": row["S.No"],
                            "Case Type": row["Case Type"],
                            "Case No.": row["Case No."],
                            "Title": truncateTitleForDisplay(row["Title"]),
                            "File No.": matchResult.fno,
                            "Matched Details": matchResult.verb,
                            "Check": matchResult.chk
                        };
                    });

                    const found = results.filter(r => r["File No."]).length;
                    setStats({
                        total: results.length,
                        found: found,
                        missing: results.length - found,
                        rate: results.length ? ((found / results.length) * 100).toFixed(1) : 0
                    });

                    setProcessedData(results);
                    setLoading(false);
                    setStep(3);
                } catch (err) {
                    console.error(err);
                    addLog(`Error: ${err.message}`);
                    setLoading(false);
                }
            };

            const exportExcel = () => {
                let dataToExport = processedData;
                
                if (exportMode === 'cleaned') {
                    dataToExport = processedData.filter(r => r["File No."] && String(r["File No."]).trim() !== "");
                }

                const ws = XLSX.utils.json_to_sheet(dataToExport);
                const wscols = [{wch: 6}, {wch: 10}, {wch: 15}, {wch: 40}, {wch: 15}, {wch: 50}, {wch: 20}];
                ws['!cols'] = wscols;
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Causelist");
                const filename = exportMode === 'cleaned' ? "Causelist_Cleaned.xlsx" : "Causelist_Full.xlsx";
                XLSX.writeFile(wb, filename);
            };

            return (
                <div className="max-w-lg mx-auto min-h-screen bg-white shadow-2xl overflow-hidden flex flex-col">
                    <div className="bg-slate-800 p-4 text-white shadow-md z-10">
                        <h1 className="text-xl font-bold tracking-wide flex items-center gap-2">
                            <span className="bg-blue-500 p-1 rounded">CM</span>
                            Case Matcher Pro
                        </h1>
                        <p className="text-slate-400 text-xs mt-1">v3.3: Export Options Added</p>
                    </div>

                    <div className="flex-1 p-6 flex flex-col">
                        <div className="flex mb-8 justify-between relative px-4">
                             <div className="absolute top-1/2 left-4 right-4 h-1 bg-slate-200 -z-10 transform -translate-y-1/2"></div>
                             {[1, 2, 3].map(s => (
                                 <div key={s} className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-sm transition-colors duration-300 
                                    ${step >= s ? 'bg-blue-600 text-white ring-4 ring-white' : 'bg-slate-200 text-slate-500'}`}>
                                    {s}
                                 </div>
                             ))}
                        </div>

                        {step === 1 && (
                            <div className="fade-in">
                                <div className="bg-blue-50 border border-blue-100 rounded-lg p-4 mb-4 text-sm text-blue-800">
                                    <strong>Step 1:</strong> Upload Master Database.
                                </div>
                                <label className="flex flex-col w-full h-40 border-2 border-slate-300 border-dashed rounded-xl cursor-pointer hover:bg-slate-50 hover:border-blue-400 transition-all group">
                                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                                        <div className="p-3 bg-slate-100 rounded-full mb-3 group-hover:bg-blue-100 transition-colors">
                                            <svg className="w-6 h-6 text-slate-500 group-hover:text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4"></path></svg>
                                        </div>
                                        <p className="text-sm text-slate-500 font-medium">Upload Master File</p>
                                    </div>
                                    <input type="file" className="hidden" accept=".xlsx,.xls,.csv" onChange={handleMasterUpload} disabled={loading} />
                                </label>
                            </div>
                        )}

                        {step === 2 && (
                            <div className="fade-in">
                                <div className="bg-green-50 border border-green-100 rounded-lg p-4 mb-4 text-sm text-green-800">
                                    <strong>Step 2:</strong> Upload Causelist PDF.
                                </div>
                                <label className="flex flex-col w-full h-40 border-2 border-slate-300 border-dashed rounded-xl cursor-pointer hover:bg-slate-50 hover:border-red-400 transition-all group">
                                    <div className="flex flex-col items-center justify-center pt-5 pb-6">
                                        <div className="p-3 bg-slate-100 rounded-full mb-3 group-hover:bg-red-100 transition-colors">
                                            <svg className="w-6 h-6 text-slate-500 group-hover:text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>
                                        </div>
                                        <p className="text-sm text-slate-500 font-medium">Upload PDF</p>
                                    </div>
                                    <input type="file" className="hidden" accept=".pdf" onChange={handlePdfUpload} disabled={loading} />
                                </label>
                            </div>
                        )}

                        {step === 3 && stats && (
                            <div className="fade-in flex flex-col h-full">
                                <div className="grid grid-cols-3 gap-3 mb-6">
                                    <div className="bg-slate-100 p-4 rounded-lg text-center border border-slate-200">
                                        <div className="text-xl font-bold text-slate-700">{stats.total}</div>
                                        <div className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Cases</div>
                                    </div>
                                    <div className="bg-green-50 p-4 rounded-lg text-center border border-green-100">
                                        <div className="text-xl font-bold text-green-600">{stats.found}</div>
                                        <div className="text-[10px] font-bold text-green-400 uppercase tracking-wider">Matched</div>
                                    </div>
                                    <div className="bg-red-50 p-4 rounded-lg text-center border border-red-100">
                                        <div className="text-xl font-bold text-red-600">{stats.missing}</div>
                                        <div className="text-[10px] font-bold text-red-400 uppercase tracking-wider">Unmatched</div>
                                    </div>
                                </div>

                                {/* Export Mode Selection */}
                                <div className="bg-slate-50 p-1 rounded-lg flex text-sm mb-3 border border-slate-200">
                                    <button 
                                        onClick={() => setExportMode('cleaned')} 
                                        className={`flex-1 py-2 rounded-md font-medium transition-all ${exportMode === 'cleaned' ? 'bg-white text-green-600 shadow-sm ring-1 ring-slate-200' : 'text-slate-500 hover:text-slate-700'}`}
                                    >
                                        Cleaned (Matches Only)
                                    </button>
                                    <button 
                                        onClick={() => setExportMode('full')} 
                                        className={`flex-1 py-2 rounded-md font-medium transition-all ${exportMode === 'full' ? 'bg-white text-blue-600 shadow-sm ring-1 ring-slate-200' : 'text-slate-500 hover:text-slate-700'}`}
                                    >
                                        Full List (All)
                                    </button>
                                </div>

                                <button onClick={exportExcel} className={`w-full py-4 rounded-xl font-semibold shadow-lg transition-all flex items-center justify-center mb-4 ${exportMode === 'cleaned' ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-blue-600 hover:bg-blue-700 text-white'}`}>
                                    <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                                    Download {exportMode === 'cleaned' ? 'Cleaned' : 'Full'} Excel
                                </button>

                                <button onClick={() => { setStep(1); setMasterData(null); setProcessedData(null); }} className="text-sm text-slate-500 hover:text-blue-600 font-medium text-center">
                                    Start Over
                                </button>

                                <div className="mt-6 flex-1 overflow-hidden border rounded-lg bg-white flex flex-col">
                                    <div className="bg-slate-100 p-2 text-xs font-bold text-slate-500 uppercase tracking-wide border-b">Preview</div>
                                    <div className="overflow-auto flex-1">
                                        <table className="w-full text-left text-sm">
                                            <tbody>
                                                {processedData.slice(0, 100).map((row, i) => (
                                                    <tr key={i} className={`border-b last:border-0 ${row["File No."] ? "bg-green-50/50" : "bg-white"}`}>
                                                        <td className="p-3 text-xs text-slate-400 w-12">{row["S.No"]}</td>
                                                        <td className="p-3">
                                                            <div className="font-medium text-slate-700">{row["Case Type"]} {row["Case No."]}</div>
                                                            <div className="text-xs text-slate-500 truncate max-w-[180px]">{row["Title"]}</div>
                                                        </td>
                                                        <td className="p-3 text-right">
                                                            {row["File No."] ? (
                                                                <span className="inline-block bg-green-100 text-green-700 px-2 py-1 rounded text-xs font-bold">{row["File No."]}</span>
                                                            ) : (
                                                                <span className="text-slate-300 text-xs">-</span>
                                                            )}
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        )}

                        {loading && (
                            <div className="absolute inset-0 bg-white/95 z-50 flex flex-col items-center justify-center p-8 text-center backdrop-blur-sm">
                                <div className="spinner mb-6 border-blue-500 border-t-transparent"></div>
                                <p className="text-lg font-bold text-slate-700 animate-pulse">Processing...</p>
                                <div className="w-full max-w-xs mt-4 bg-slate-100 rounded-lg p-3 font-mono text-xs text-slate-500 text-left h-32 overflow-hidden border border-slate-200 shadow-inner">
                                    {logs.map((l, i) => <div key={i} className="truncate mb-1">â†’ {l}</div>)}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<App />);
    </script>
</body>
</html>